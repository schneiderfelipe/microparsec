<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- CSS -->
<title>microparsec/combinators</title>
<link rel="stylesheet" type="text/css" href="../nimdoc.out.css">

<script type="text/javascript" src="../dochack.js"></script>

<script type="text/javascript">
function main() {
  var pragmaDots = document.getElementsByClassName("pragmadots");
  for (var i = 0; i < pragmaDots.length; i++) {
    pragmaDots[i].onclick = function(event) {
      // Hide tease
      event.target.parentNode.style.display = "none";
      // Show actual
      event.target.parentNode.nextElementSibling.style.display = "inline";
    }
  }

  const toggleSwitch = document.querySelector('.theme-switch input[type="checkbox"]');
  function switchTheme(e) {
      if (e.target.checked) {
          document.documentElement.setAttribute('data-theme', 'dark');
          localStorage.setItem('theme', 'dark');
      } else {
          document.documentElement.setAttribute('data-theme', 'light');
          localStorage.setItem('theme', 'light');
      }
  }

  toggleSwitch.addEventListener('change', switchTheme, false);

  const currentTheme = localStorage.getItem('theme') ? localStorage.getItem('theme') : null;
  if (currentTheme) {
    document.documentElement.setAttribute('data-theme', currentTheme);

    if (currentTheme === 'dark') {
      toggleSwitch.checked = true;
    }
  }
}
</script>

</head>
<body onload="main()">
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">microparsec/combinators</h1>
    <div class="row">
  <div class="three columns">
  <div class="theme-switch-wrapper">
    <label class="theme-switch" for="checkbox">
      <input type="checkbox" id="checkbox" />
      <div class="slider round"></div>
    </label>
    &nbsp;&nbsp;&nbsp; <em>Dark Mode</em>
  </div>
  <div id="global-links">
    <ul class="simple">
    <li>
      <a href="../theindex.html">Index</a>
    </li>
    </ul>
  </div>
  <div id="searchInputDiv">
    Search: <input type="text" id="searchInput"
      onkeyup="search()" />
  </div>
  <div>
    Group by:
    <select onchange="groupBy(this.value)">
      <option value="section">Section</option>
      <option value="type">Type</option>
    </select>
  </div>
  <ul class="simple simple-toc" id="toc-list">
<li>
  <a class="reference reference-toplevel" href="#6" id="56">Imports</a>
  <ul class="simple simple-toc-section">
    
  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#13" id="63">Funcs</a>
  <ul class="simple simple-toc-section">
      <ul class="simple nested-toc-section">sepBy1
      <li><a class="reference" href="#sepBy1%2CParser%5BT%5D%2CParser%5BS%5D"
    title="sepBy1[S, T](parser: Parser[T]; separator: Parser[S]): Parser[seq[T]]">sepBy1,<wbr>Parser[T],<wbr>Parser[S]</a></li>

  </ul>
  <ul class="simple nested-toc-section">manyTill
      <li><a class="reference" href="#manyTill%2CParser%5BT%5D%2CParser%5BS%5D"
    title="manyTill[S, T](parser: Parser[T]; endparser: Parser[S]): Parser[seq[T]]">manyTill,<wbr>Parser[T],<wbr>Parser[S]</a></li>

  </ul>
  <ul class="simple nested-toc-section">skipMany
      <li><a class="reference" href="#skipMany%2CParser%5BT%5D"
    title="skipMany[T](parser: Parser[T]): Parser[void]">skipMany,<wbr>Parser[T]</a></li>

  </ul>
  <ul class="simple nested-toc-section">choice
      <li><a class="reference" href="#choice%2CopenArray%5BParser%5BT%5D%5D"
    title="choice[T](parsers: openArray[Parser[T]]): Parser[T]">choice,<wbr>openArray[Parser[T]]</a></li>

  </ul>
  <ul class="simple nested-toc-section"><?>
      <li><a class="reference" href="#%3C%3F%3E%2CParser%5BT%5D%2Cstring"
    title="`&lt;?&gt;`[T](parser: Parser[T]; expected: string): Parser[T]"><?>,<wbr>Parser[T],<wbr>string</a></li>

  </ul>
  <ul class="simple nested-toc-section">count
      <li><a class="reference" href="#count%2Cint%2CParser%5BT%5D"
    title="count[T](n: int; parser: Parser[T]): Parser[seq[T]]">count,<wbr>int,<wbr>Parser[T]</a></li>

  </ul>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#18" id="68">Templates</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#attempt.t%2CParser%5BT%5D"
    title="attempt[T](parser: Parser[T]): Parser[T]">attempt</a></li>
  <li><a class="reference" href="#option.t%2CT%2CParser%5BT%5D"
    title="option[T](x: T; parser: Parser[T]): Parser[T]">option</a></li>
  <li><a class="reference" href="#many1.t%2CParser%5BT%5D"
    title="many1[T](parser: Parser[T]): Parser[seq[T]]">many1</a></li>
  <li><a class="reference" href="#sepBy.t%2CParser%5BT%5D%2CParser%5BS%5D"
    title="sepBy[S; T](parser: Parser[T]; separator: Parser[S]): Parser[seq[T]]">sepBy</a></li>
  <li><a class="reference" href="#skipMany1.t%2CParser%5BT%5D"
    title="skipMany1[T](parser: Parser[T]): Parser[void]">skipMany1</a></li>
  <li><a class="reference" href="#optional.t%2CParser%5BT%5D"
    title="optional[T](parser: Parser[T]): Parser[void]">optional</a></li>
  <li><a class="reference" href="#between.t%2CParser%5BR%5D%2CParser%5BT%5D%2CParser%5BS%5D"
    title="between[R; S; T](open: Parser[R]; parser: Parser[T]; close: Parser[S]): Parser[T]">between</a></li>
  <li><a class="reference" href="#eof.t%2CParseState"
    title="eof(state: ParseState): ParseResult[void]">eof</a></li>

  </ul>
</li>

</ul>

  </div>
  <div class="nine columns" id="content">
  <div id="tocRoot"></div>
  
  <p class="module-desc"></p>
  <div class="section" id="6">
<h1><a class="toc-backref" href="#6">Imports</a></h1>
<dl class="item">
<a class="reference external" href="primitives.html">primitives</a>, <a class="reference external" href="types.html">types</a>
</dl></div>
<div class="section" id="13">
<h1><a class="toc-backref" href="#13">Funcs</a></h1>
<dl class="item">
<a id="<?>,Parser[T],string"></a>
<dt><pre><span class="Keyword">func</span> <a href="#%3C%3F%3E%2CParser%5BT%5D%2Cstring"><span class="Identifier">`&lt;?&gt;`</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">parser</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">expected</span><span class="Other">:</span> <span class="Identifier">string</span><span class="Other">)</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">inline</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Build a <tt class="docutils literal"><span class="pre">Parser</span></tt> that behaves as <tt class="docutils literal"><span class="pre">parser</span></tt>, but whenever <tt class="docutils literal"><span class="pre">parser</span></tt> fails, it replaces expect error messages with <tt class="docutils literal"><span class="pre">expected</span></tt>. As such, this function effectively names a parser, in case failure occurs.</p>
<p>This is normally used at the end of a set alternatives where we want to return an error message in terms of a higher level construct rather than returning all possible characters.</p>
<p><strong>Note</strong>: In the future, this might become a template, so that functions such as <tt class="docutils literal"><span class="pre">satisfy</span></tt> won't need a <tt class="docutils literal"><span class="pre">expected</span></tt> parameter for performance reasons.</p>

&nbsp;&nbsp;<a
href="https://github.com/schneiderfelipe/microparsec/tree/master/src/microparsec/combinators.nim#L22"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/schneiderfelipe/microparsec/edit/devel/src/microparsec/combinators.nim#L22" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<a id="choice,openArray[Parser[T]]"></a>
<dt><pre><span class="Keyword">func</span> <a href="#choice%2CopenArray%5BParser%5BT%5D%5D"><span class="Identifier">choice</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">parsers</span><span class="Other">:</span> <span class="Identifier">openArray</span><span class="Other">[</span><a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">inline</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>A <tt class="docutils literal"><span class="pre">Parser</span></tt> that tries to apply the actions in a sequence in order, until one of them succeeds. Returns the value of the succeeding action.</p>
<p><strong>Note</strong>: This might use <tt class="docutils literal"><span class="pre">varargs</span></tt> in the future, but this proves to be more convenient. Furthermore, the current behavior is undefined for an empty sequence of parsers. In the future, this will be based in an Alternative <tt class="docutils literal"><span class="pre">empty</span></tt>.</p>

&nbsp;&nbsp;<a
href="https://github.com/schneiderfelipe/microparsec/tree/master/src/microparsec/combinators.nim#L40"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/schneiderfelipe/microparsec/edit/devel/src/microparsec/combinators.nim#L40" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<a id="sepBy1,Parser[T],Parser[S]"></a>
<dt><pre><span class="Keyword">func</span> <a href="#sepBy1%2CParser%5BT%5D%2CParser%5BS%5D"><span class="Identifier">sepBy1</span></a><span class="Other">[</span><span class="Identifier">S</span><span class="Other">,</span> <span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">parser</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">separator</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">S</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">]</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma">
    <span class="Identifier">inline</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Create a <tt class="docutils literal"><span class="pre">Parser</span></tt> that applies <em>one</em> or more occurrences of <tt class="docutils literal"><span class="pre">parser</span></tt>, separated by <tt class="docutils literal"><span class="pre">separator</span></tt>. Returns a sequence of the values returned by <tt class="docutils literal"><span class="pre">parser</span></tt>.</p>
<p><strong>Note</strong>: Currently, <tt class="docutils literal"><span class="pre">sepBy</span></tt> is defined in function of this function. This might change in the future, if the implementation can be made simpler some other way.</p>

&nbsp;&nbsp;<a
href="https://github.com/schneiderfelipe/microparsec/tree/master/src/microparsec/combinators.nim#L99"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/schneiderfelipe/microparsec/edit/devel/src/microparsec/combinators.nim#L99" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<a id="manyTill,Parser[T],Parser[S]"></a>
<dt><pre><span class="Keyword">func</span> <a href="#manyTill%2CParser%5BT%5D%2CParser%5BS%5D"><span class="Identifier">manyTill</span></a><span class="Other">[</span><span class="Identifier">S</span><span class="Other">,</span> <span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">parser</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">endparser</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">S</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">]</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma">
    <span class="Identifier">inline</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>A <tt class="docutils literal"><span class="pre">Parser</span></tt> that applies an action <em>zero</em> or more times until another action succeeds, and returns the sequence of values returned by the first action.</p>
<p><strong>Note</strong>: Error messages are not good enough yet, but the current implementation is comparable to Attoparsec's.</p>

&nbsp;&nbsp;<a
href="https://github.com/schneiderfelipe/microparsec/tree/master/src/microparsec/combinators.nim#L124"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/schneiderfelipe/microparsec/edit/devel/src/microparsec/combinators.nim#L124" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<a id="skipMany,Parser[T]"></a>
<dt><pre><span class="Keyword">func</span> <a href="#skipMany%2CParser%5BT%5D"><span class="Identifier">skipMany</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">parser</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">void</span><span class="Other">]</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">inline</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

Build a <tt class="docutils literal"><span class="pre">Parser</span></tt> that skips <em>zero</em> or more instances of an action.
&nbsp;&nbsp;<a
href="https://github.com/schneiderfelipe/microparsec/tree/master/src/microparsec/combinators.nim#L149"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/schneiderfelipe/microparsec/edit/devel/src/microparsec/combinators.nim#L149" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<a id="count,int,Parser[T]"></a>
<dt><pre><span class="Keyword">func</span> <a href="#count%2Cint%2CParser%5BT%5D"><span class="Identifier">count</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">n</span><span class="Other">:</span> <span class="Identifier">int</span><span class="Other">;</span> <span class="Identifier">parser</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">]</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">inline</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>A <tt class="docutils literal"><span class="pre">Parser</span></tt> that applies the given action repeatedly, returning every result.</p>
<p><strong>Note</strong>: This short circuits in case of errors.</p>

&nbsp;&nbsp;<a
href="https://github.com/schneiderfelipe/microparsec/tree/master/src/microparsec/combinators.nim#L161"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/schneiderfelipe/microparsec/edit/devel/src/microparsec/combinators.nim#L161" class="link-seesrc" target="_blank" >Edit</a>

</dd>

</dl></div>
<div class="section" id="18">
<h1><a class="toc-backref" href="#18">Templates</a></h1>
<dl class="item">
<a id="attempt.t,Parser[T]"></a>
<dt><pre><span class="Keyword">template</span> <a href="#attempt.t%2CParser%5BT%5D"><span class="Identifier">attempt</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">parser</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span></pre></dt>
<dd>

<p>Create a <tt class="docutils literal"><span class="pre">Parser</span></tt> that attempts a parse, and if it fails, rewind the input so that no input appears to have been consumed.</p>
<p>This function is called <tt class="docutils literal"><span class="pre">try</span></tt> in Parsec, but this conflicts with the <tt class="docutils literal"><span class="pre">try</span></tt> keyword in Nim.</p>
<p>This combinator is provided for compatibility with Parsec. We follow Attoparsec's implementation, which always backtracks on failure.</p>
<p><strong>Note</strong>: We mean to deprecate this function once we're past 0.1 or so.</p>

&nbsp;&nbsp;<a
href="https://github.com/schneiderfelipe/microparsec/tree/master/src/microparsec/combinators.nim#L9"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/schneiderfelipe/microparsec/edit/devel/src/microparsec/combinators.nim#L9" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<a id="option.t,T,Parser[T]"></a>
<dt><pre><span class="Keyword">template</span> <a href="#option.t%2CT%2CParser%5BT%5D"><span class="Identifier">option</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">x</span><span class="Other">:</span> <span class="Identifier">T</span><span class="Other">;</span> <span class="Identifier">parser</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span></pre></dt>
<dd>

A <tt class="docutils literal"><span class="pre">Parser</span></tt> that tries to apply an action. If it fails without consuming input, it returns the value <tt class="docutils literal"><span class="pre">x</span></tt>, otherwise the value returned by the action.
&nbsp;&nbsp;<a
href="https://github.com/schneiderfelipe/microparsec/tree/master/src/microparsec/combinators.nim#L77"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/schneiderfelipe/microparsec/edit/devel/src/microparsec/combinators.nim#L77" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<a id="many1.t,Parser[T]"></a>
<dt><pre><span class="Keyword">template</span> <a href="#many1.t%2CParser%5BT%5D"><span class="Identifier">many1</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">parser</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">]</span></pre></dt>
<dd>

Build a <tt class="docutils literal"><span class="pre">Parser</span></tt> that applies another <tt class="docutils literal"><span class="pre">Parser</span></tt> <em>one</em> or more times. Returns a sequence of the parsed values.
&nbsp;&nbsp;<a
href="https://github.com/schneiderfelipe/microparsec/tree/master/src/microparsec/combinators.nim#L83"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/schneiderfelipe/microparsec/edit/devel/src/microparsec/combinators.nim#L83" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<a id="sepBy.t,Parser[T],Parser[S]"></a>
<dt><pre><span class="Keyword">template</span> <a href="#sepBy.t%2CParser%5BT%5D%2CParser%5BS%5D"><span class="Identifier">sepBy</span></a><span class="Other">[</span><span class="Identifier">S</span><span class="Other">;</span> <span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">parser</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">separator</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">S</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">]</span></pre></dt>
<dd>

<p>A <tt class="docutils literal"><span class="pre">Parser</span></tt> that applies <em>zero</em> or more occurrences of <tt class="docutils literal"><span class="pre">parser</span></tt>, separated by <tt class="docutils literal"><span class="pre">separator</span></tt>. Returns a sequence of the values returned by <tt class="docutils literal"><span class="pre">parser</span></tt>.</p>
<p><strong>Note</strong>: Attoparsec's implementation seems to be too complicated, (unnecessarily?) testing for a first occurrence. Maybe there's a performance reason, I don't know. Ours might be simpler, but there might be a catch somewhere. In any case, tests pass. Be advised, and report any issue you might find!</p>

&nbsp;&nbsp;<a
href="https://github.com/schneiderfelipe/microparsec/tree/master/src/microparsec/combinators.nim#L88"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/schneiderfelipe/microparsec/edit/devel/src/microparsec/combinators.nim#L88" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<a id="skipMany1.t,Parser[T]"></a>
<dt><pre><span class="Keyword">template</span> <a href="#skipMany1.t%2CParser%5BT%5D"><span class="Identifier">skipMany1</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">parser</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">void</span><span class="Other">]</span></pre></dt>
<dd>

Build a <tt class="docutils literal"><span class="pre">Parser</span></tt> that skips <em>one</em> or more instances of an action.
&nbsp;&nbsp;<a
href="https://github.com/schneiderfelipe/microparsec/tree/master/src/microparsec/combinators.nim#L157"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/schneiderfelipe/microparsec/edit/devel/src/microparsec/combinators.nim#L157" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<a id="optional.t,Parser[T]"></a>
<dt><pre><span class="Keyword">template</span> <a href="#optional.t%2CParser%5BT%5D"><span class="Identifier">optional</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">parser</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">void</span><span class="Other">]</span></pre></dt>
<dd>

Create a <tt class="docutils literal"><span class="pre">Parser</span></tt> that tries to apply <tt class="docutils literal"><span class="pre">parser</span></tt>. It might consume input if <tt class="docutils literal"><span class="pre">parser</span></tt> is successful and consumes input. And due to backtracking, it never fails. The result of <tt class="docutils literal"><span class="pre">parser</span></tt> is discarded.
&nbsp;&nbsp;<a
href="https://github.com/schneiderfelipe/microparsec/tree/master/src/microparsec/combinators.nim#L184"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/schneiderfelipe/microparsec/edit/devel/src/microparsec/combinators.nim#L184" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<a id="between.t,Parser[R],Parser[T],Parser[S]"></a>
<dt><pre><span class="Keyword">template</span> <a href="#between.t%2CParser%5BR%5D%2CParser%5BT%5D%2CParser%5BS%5D"><span class="Identifier">between</span></a><span class="Other">[</span><span class="Identifier">R</span><span class="Other">;</span> <span class="Identifier">S</span><span class="Other">;</span> <span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">open</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">R</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">parser</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">close</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">S</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <a href="types.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span>
    <span class="Identifier">T</span><span class="Other">]</span></pre></dt>
<dd>

<p>Create a <tt class="docutils literal"><span class="pre">Parser</span></tt> that parses <tt class="docutils literal"><span class="pre">open</span></tt>, followed by <tt class="docutils literal"><span class="pre">parser</span></tt> and then <tt class="docutils literal"><span class="pre">close</span></tt>, returning the value given by <tt class="docutils literal"><span class="pre">parser</span></tt>.</p>
<p><strong>Note</strong>: This function is experimental.</p>

&nbsp;&nbsp;<a
href="https://github.com/schneiderfelipe/microparsec/tree/master/src/microparsec/combinators.nim#L190"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/schneiderfelipe/microparsec/edit/devel/src/microparsec/combinators.nim#L190" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<a id="eof.t,ParseState"></a>
<dt><pre><span class="Keyword">template</span> <a href="#eof.t%2CParseState"><span class="Identifier">eof</span></a><span class="Other">(</span><span class="Identifier">state</span><span class="Other">:</span> <a href="types.html#ParseState"><span class="Identifier">ParseState</span></a><span class="Other">)</span><span class="Other">:</span> <a href="types.html#ParseResult"><span class="Identifier">ParseResult</span></a><span class="Other">[</span><span class="Identifier">void</span><span class="Other">]</span></pre></dt>
<dd>

A <tt class="docutils literal"><span class="pre">Parser</span></tt> that only succeeds at the end of the input. This is not a primitive parser but it is defined using <tt class="docutils literal"><span class="pre">notFollowedBy</span></tt>.
&nbsp;&nbsp;<a
href="https://github.com/schneiderfelipe/microparsec/tree/master/src/microparsec/combinators.nim#L203"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/schneiderfelipe/microparsec/edit/devel/src/microparsec/combinators.nim#L203" class="link-seesrc" target="_blank" >Edit</a>

</dd>

</dl></div>

  </div>
</div>

    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br/>
        <small style="color: var(--hint);">Made with Nim. Generated: 2021-07-05 02:03:22 UTC</small>
      </div>
    </div>
  </div>
</div>

</body>
</html>
